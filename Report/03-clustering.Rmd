# Clustering

```{r message=FALSE, warning=FALSE, include=FALSE}
# source a set of functions
source("util.R")

# import libraries
libraries_list <- c("ggraph", "igraph", "dplyr", "readr", "DiagrammeR", "tidyverse",
                    "Cairo", "networkD3", "CINNA", "scales", "gridExtra", "leiden")
import_libraries(libraries_list)

# import graph
edges <- read.csv(
  "../dataset/diseasome [Edges].csv",
  head = TRUE
)

nodes <- read.csv(
  "../dataset/diseasome [Nodes].csv",
  head = TRUE
)

nodes <- nodes %>% select(-timeset)
edges <- edges %>% select(-timeset, -label)

graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)
# print(graph, e=TRUE, v=TRUE) ## IGRAPH 9af20f4 DNW- 1419 3926
```

Settiamo il peso di ogni arco pari al numero di geni che condividono le malattie:
```{r}
# for (i in 1:length(edges[, 5]))
# {
#   edge <- edges[i, ]
# 
#   n1 <- V(graph)[as.character(edge$Source)]
#   n2 <- V(graph)[as.character(edge$Target)]
# 
#   n1.neigh <- neighborhood(graph, nodes = n1)[[1]]
#   n2.neigh <- neighborhood(graph, nodes = n2)[[1]]
# 
#   n1.neigh <- as.numeric(n1.neigh[n1.neigh$X1 == "gene"])
#   n2.neigh <- as.numeric(n2.neigh[n2.neigh$X1 == "gene"])
# 
#   weight <- length(intersect(n1.neigh, n2.neigh))
# 
#   edges[i, ]$weight <- weight
# }

weight <- readRDS("edgeweights.rds")
edges$weight <- weight
```

Creiamo il grafo finale:
```{r}
graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)

UD_nogenes <- induced_subgraph(graph, which(nodes$X1 != "gene"))

# Rimuovo i doppi nodi
UD_nogenes <- igraph::simplify(UD_nogenes)
```

Le malattie sono già clusterizzate in macrogruppi medici (cancro, cardiovascolare, etc...), proviamo a vedere se questi cluster si trovano vicini all'interno della rete:
```{r}
disease_clusters <- unique(nodes$X1)

i = 1
for (disease in disease_clusters)
{
  V(UD_nogenes)[V(UD_nogenes)$X1 == disease]$color = i
  i = i + 1
}

ggraph(UD_nogenes, layout = "kk") +
  geom_edge_fan(colour = "gray", show.legend = TRUE) + 
  geom_node_point(aes(colour = V(UD_nogenes)$color)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Clusters")
```

```{r}
graphs <- NULL
plots <- NULL
i <- 1

for (disease in disease_clusters)
{
  if (disease == "gene")
    next
    
  graphs[[i]] <- induced.subgraph(UD_nogenes, which(V(UD_nogenes)$X1 == disease))
  
  if (disease %in% c("Unclassified", "Respiratory"))
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_node_point() +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  } else
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_edge_fan(colour = "gray", show.legend = TRUE) +
      geom_node_point(colour = "red") +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  }
  i = i + 1
}

# grid.arrange(grobs = plots)
```

Vediamo quante componenti connesse abbiamo per ogni cluster:
```{r}
n.cluster <- 0

for (g in graphs)
{
  component <- components(g)
  n.cluster = n.cluster + length(component$csize[component$csize > 0])
}

print(n.cluster)
```

```{r}
nodes_results <- nodes %>% filter(X1 != "gene") %>% select(-X0)
nodes_results$Betweenness <- NA
nodes_results$Fastgreedy <- NA
nodes_results$Louvain <- NA
nodes_results$Spinglass <- NA
nodes_results$Markov <- NA
nodes_results$Leiden <- NA
nodes_results$Label_prop <- NA

```

## Regola di clustering
Ogni cluster viene labellato con la label più frequente all'interno del cluster:
```{r}
label_cluster <- function(clusters)
{
  cluster_df <-
    as.data.frame(matrix(
      1:length(clusters),
      nrow = length(clusters),
      dimnames = list(NULL, "id")
    ))
  
  for (c in 1:length(clusters))
  {
    labels <- V(UD_nogenes)[clusters[[c]]]$X1
    labels <- labels[labels != "Multiple"]
    
    if (length(labels) != 0)
    {
      value <- which.max(unlist(table(labels)))

      cluster_df$name[cluster_df$id == c] <- names(value)[1]
    } else
    {
      cluster_df$name[cluster_df$id == c] <- "Multiple"
    }

  }
  
  return(cluster_df)
}
```

## Edge betweennes

Primo algoritmo di clustering

```{r}
betweennes.communities <- cluster_edge_betweenness(UD_nogenes, directed = FALSE, weights = E(UD_nogenes)$weight)

betweennes_cluster_df <- label_cluster(betweennes.communities)

for (n in 1:length(betweennes.communities$membership))
{
  nodes_results$Betweenness[n] <- betweennes_cluster_df$name[betweennes.communities$membership[n]]
}
```

## Fastgreedy
Secondo algoritmo di clustering:
```{r}
fgreedy.communities <- cluster_fast_greedy(UD_nogenes, modularity = TRUE, weights = E(UD_nogenes)$weight)

V(UD_nogenes)[fgreedy.communities[[5]]]$X1

fgreedy.communities #IGRAPH clustering fast greedy, groups: 26 (communities), mod: 0.82 

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = fgreedy.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Fastgreedy Membership")

```


```{r}
fgreedy_cluster_df <- label_cluster(fgreedy.communities)

for (n in 1:length(fgreedy.communities$membership))
{
  nodes_results$Fastgreedy[n] <- fgreedy_cluster_df$name[fgreedy.communities$membership[n]]
}
```

## Louvain
Terzo algoritmo di clustering:
```{r}
louvain.communities <- cluster_louvain(UD_nogenes, weights = E(UD_nogenes)$weight)

louvain.communities #IGRAPH clustering multi level, groups: 27 (communities), mod: 0.83 + groups:  

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = louvain.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Louvain Membership")

```

```{r}
louvain_cluster_df <- label_cluster(louvain.communities)

for (n in 1:length(louvain.communities$membership))
{
  nodes_results$Louvain[n] <- louvain_cluster_df$name[louvain.communities$membership[n]]
}

```

## Spinglass
Quarto algoritmo di clustering:
```{r}
spinglass.communities <- cluster_spinglass(UD_nogenes, spins = 197, weights = E(UD_nogenes)$weight)

spinglass.communities #IGRAPH clustering spinglass, groups: varia... 39/43 ... (communities), mod: 0.4 

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = spinglass.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Spinglass Membership")

```

```{r}
spinglass_cluster_df <- label_cluster(spinglass.communities)

for (n in 1:length(spinglass.communities$membership))
{
  nodes_results$Spinglass[n] <- spinglass_cluster_df$name[spinglass.communities$membership[n]]
}
```

## Markov Cluster Algorithm
Quinto algoritmo di clustering:
```{r}
library(MCL)
adjmat <- as_adj(UD_nogenes, type = "both", attr = "weight")

mcl.communities <- mcl(adjmat, addLoops = FALSE, inflation = 4, allow1 = TRUE) # 169 cluster

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = mcl.communities$Cluster)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Markov Clusters")

```
Esempio di sottografo con label cancer
```{r}
mcl_cancer_subgraph <- induced_subgraph(UD_nogenes, V(UD_nogenes)[mcl.communities$Cluster == 3])

ggraph(mcl_cancer_subgraph, layout = 'kk') +
  geom_edge_fan(colour = "gray", show.legend = TRUE) +
  geom_node_point(colour = "red") +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Cancer MCL subgraph")
```

```{r}
markov_cluster_df <- as.data.frame(matrix(1:(mcl.communities$K), nrow = mcl.communities$K, dimnames = list(NULL, "id")))
markov_cluster_df$name <- NA
markov_cluster_df$id <- unique(mcl.communities$Cluster)

for (id in markov_cluster_df$id)
{

    labels <- V(UD_nogenes)[mcl.communities$Cluster == id]$X1
    labels <- labels[labels != "Multiple"]
    
    value <- which.max(unlist(table(labels)))
    
    
    if (length(value) != 0)
    {
      markov_cluster_df$name[markov_cluster_df$id == id] <- names(value)[1]
    }
}
  
for (n in 1:length(mcl.communities$Cluster))
{
  nodes_results$Markov[n] <- markov_cluster_df$name[mcl.communities$Cluster[n] == markov_cluster_df$id]
}
```

## Leiden Algorithm
Sesto algoritmo di clustering, dovrebbe migliorare i risultati e anche la rapidità di esecuzione di louvain:
```{r}
library(leiden)
adjmat <- as_adj(UD_nogenes, type = "both", attr = "weight")

leiden.communities <- leiden(adjmat, resolution_parameter = 70)

print(max(leiden.communities))
leiden.communities <- make_clusters(UD_nogenes, membership = leiden.communities)

```

```{r}
leiden_cluster_df <- label_cluster(leiden.communities)

for (n in 1:length(leiden.communities$membership))
{
  nodes_results$Leiden[n] <- leiden_cluster_df$name[leiden.communities$membership[n]]
}
```


## Label propagation

Settimo algoritmo di clustering.
Label propagation senza inizializzazione

```{r}
label_prop.communities <- cluster_label_prop(UD_nogenes, weights = E(UD_nogenes)$weight)
```

```{r}
label_prop_cluster_df <- label_cluster(label_prop.communities)

for (n in 1:length(label_prop.communities$membership))
{
  nodes_results$Label_prop[n] <- label_prop_cluster_df$name[label_prop.communities$membership[n]]
}
```

Proviamo a fissare alcune label:

```{r}

V(UD_nogenes)$initial <- NA
V(UD_nogenes)$fixed <- NA

# Questo dovrebbe etichettare un po' di cluster singoli e un po' dei loro vicini per arrivare ad un 20% di nodi già labellati
# Però le performance degradano fino al 40% :)
# for (g in graphs)
# {
#   component <- components(g)
#   for (i in 1:length(components(g)$csize))
#   {
#     if (component$csize[i] == 1)
#     {
#       node_idx <- component$membership[component$membership == i]
#       
#       node <- names(node_idx)
#       
#       if (runif(1) < 0.5)
#       {
#         V(UD_nogenes)[node]$initial <- which(disease_clusters == V(UD_nogenes)[node]$X1)
#         V(UD_nogenes)[node]$fixed <- TRUE
#         
#         for (idx in neighborhood(UD_nogenes, nodes = node_idx, order = 3))
#         {
#           if (runif(1) < 0.009)
#           {
#             V(UD_nogenes)[idx]$initial <- which(disease_clusters == V(UD_nogenes)[idx]$X1)
#             V(UD_nogenes)[idx]$fixed <- TRUE
#           }
#         }
#       }
#       
#     }
#   }
# }

for (i in 1:length(V(UD_nogenes)))
{
  if (runif(1) < 0.2)
  {
    V(UD_nogenes)[i]$initial <- which(disease_clusters == V(UD_nogenes)[i]$X1)
    V(UD_nogenes)[i]$fixed <- TRUE
  }
}

V(UD_nogenes)$initial[is.na(V(UD_nogenes)$initial)] <- -1
V(UD_nogenes)$fixed[is.na(V(UD_nogenes)$fixed)] <- FALSE

label_prop_init.communities <- cluster_label_prop(UD_nogenes, weights = E(UD_nogenes)$weight,
                                                  initial = V(UD_nogenes)$initial, fixed = V(UD_nogenes)$fixed)

label_prop_init_cluster_df <- label_cluster(label_prop_init.communities)

for (n in 1:length(label_prop_init.communities$membership))
{
  nodes_results$Label_prop_init[n] <- label_prop_init_cluster_df$name[label_prop_init.communities$membership[n]]
}
```

## Analysis 
Confusion matrix and accuracy

```{r message=FALSE, warning=FALSE}
library(caret)

compute_confmat <- function(groundtruth, communities.algo)
{
  l.union <- union(groundtruth, communities.algo)
  
  groundtruth[groundtruth == "Multiple"] <- communities.algo[groundtruth == "Multiple"]
  
  atable <-
    table(
      factor(groundtruth, l.union),
      factor(communities.algo, l.union)
    )
  
  return(confusionMatrix(atable))
}

betweennes_confmat <- compute_confmat(nodes_results$X1, nodes_results$Betweenness)

fastgreedy_confmat <- compute_confmat(nodes_results$X1, nodes_results$Fastgreedy)

louvain_confmat <- compute_confmat(nodes_results$X1, nodes_results$Louvain)

spinglass_confmat <- compute_confmat(nodes_results$X1, nodes_results$Spinglass)

markov_confmat <- compute_confmat(nodes_results$X1, nodes_results$Markov)

leiden_confmat <- compute_confmat(nodes_results$X1, nodes_results$Leiden)

label_prop_confmat <- compute_confmat(nodes_results$X1, nodes_results$Label_prop)

label_prop_init_confmat <- compute_confmat(nodes_results$X1, nodes_results$Label_prop_init)

cat("betweennes")
betweennes_confmat$overall[1]

cat("fastgreedy")
fastgreedy_confmat$overall[1]

cat("louvain")
louvain_confmat$overall[1]

cat("spinglass")
spinglass_confmat$overall[1]

cat("markov")
markov_confmat$overall[1]

cat("leiden")
leiden_confmat$overall[1]

cat("label propagation")
label_prop_confmat$overall[1]

cat("label propagation with initialization")
label_prop_init_confmat$overall[1]
```
#### Analisi sulle malattie che venivano contrassegnate come Unclassified:
```{r}
unclassified_disease <- nodes_results %>% filter(X1 == "Unclassified")
unclassified_disease
```

- Bannayan-Riley-Ruvalcaba syndrome identificata da tutti e quattro gli algoritmi come cancer: 
da alcune risorse (https://omim.org/entry/158350?search=bannayan-riley-ruvalcaba%20syndrome&highlight=%22bannayan%20riley%20ruvalcaba%20syndrome%22%20%22bannayan%20riley%20ruvalcaba%20syndromic%22%20%22bannayan%20riley%20ruvalcaba%22%20%22bannayanrileyruvalcaba%20syndrome%22%20%22bannayanrileyruvalcaba%20syndromic%22%20bannayanrileyruvalcaba%20syndrome%20syndromic) pare ci sia un collegamento con il cancro al seno.

- Benzene toxicity susceptibility to : leukemia, post-chemotherapy, susceptibility to, included
breast cancer, post-chemotherapy poor survival in

- Aquaporin-1 deficiency classicifata in Hematological: 
collegamenti rilevati :Blood group, Colton


#### Analisi sulle malattie che venivano contrassegnate come Multiple:
```{r}
multiple_disease <- nodes_results %>% filter(X1 == "Multiple")
multiple_disease
```

- Fanconi anemia is a clinically and genetically heterogeneous disorder that causes genomic instability. Characteristic clinical features include developmental abnormalities in major organ systems, early-onset bone marrow failure, and a high predisposition to cancer

- Dejerine-Sottas neuropathy is a demyelinating peripheral neuropathy with onset in infancy

