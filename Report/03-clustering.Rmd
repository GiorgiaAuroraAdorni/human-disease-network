# Clustering

```{r message=FALSE, warning=FALSE, include=FALSE}
# source a set of functions
source("util.R")

# import libraries
libraries_list <- c("ggraph", "igraph", "dplyr", "readr", "DiagrammeR", "tidyverse",
                    "Cairo", "networkD3", "CINNA", "scales", "gridExtra", "leiden",
                    "colorspace", "RColorBrewer", "viridis", "graphics")
import_libraries(libraries_list)

# import graph
edges <- read.csv(
  "../dataset/diseasome [Edges].csv",
  head = TRUE
)

nodes <- read.csv(
  "../dataset/diseasome [Nodes].csv",
  head = TRUE
)

nodes <- nodes %>% select(-timeset)
edges <- edges %>% select(-timeset, -label)

graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)
# print(graph, e=TRUE, v=TRUE) ## IGRAPH 9af20f4 DNW- 1419 3926
```

Settiamo il peso di ogni arco pari al numero di geni che condividono le malattie:
```{r}
for (i in 1:length(edges[, 5]))
{
  edge <- edges[i, ]
  
  n1 <- V(graph)[as.character(edge$Source)]
  n2 <- V(graph)[as.character(edge$Target)]
  
  n1.neigh <- neighborhood(graph, nodes = n1)[[1]]
  n2.neigh <- neighborhood(graph, nodes = n2)[[1]]
  
  n1.neigh <- as.numeric(n1.neigh[n1.neigh$X1 == "gene"])
  n2.neigh <- as.numeric(n2.neigh[n2.neigh$X1 == "gene"])
  
  weight <- length(intersect(n1.neigh, n2.neigh))
  
  edges[i, ]$weight <- weight
}

graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)
```

Le malattie sono già clusterizzate in macrogruppi medici (cancro, cardiovascolare, etc...), proviamo a vedere se questi cluster si trovano vicini all'interno della rete:
```{r}
UD_nogenes <- induced_subgraph(graph, which(nodes$X1 != "gene"))

# Rimuovo i doppi nodi
UD_nogenes <- igraph::simplify(UD_nogenes)

disease_clusters <- unique(nodes$X1)

i = 1
for (disease in disease_clusters)
{
  V(UD_nogenes)[V(UD_nogenes)$X1 == disease]$color = i
  i = i + 1
}

plot_pretty_graph(UD_nogenes, "graphopt", V(UD_nogenes)$color, 22, E(UD_nogenes)$weight, 
                  "Human Disease Network Clusters")
```

```{r}
graphs <- NULL
plots <- NULL
i <- 1

for (disease in disease_clusters)
{
  if (disease == "gene")
    next
    
  graphs[[i]] <- induced.subgraph(UD_nogenes, which(V(UD_nogenes)$X1 == disease))
  
  if (disease %in% c("Unclassified", "Respiratory"))
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_node_point() +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  } else
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_edge_fan(colour = "gray", show.legend = TRUE) +
      geom_node_point(colour = "red") +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  }
  i = i + 1
}

# grid.arrange(grobs = plots)
```

Vediamo quante componenti connesse abbiamo per ogni cluster:
```{r}

n.cluster <- 0

for (g in graphs)
{
  component <- components(g)
  n.cluster = n.cluster + length(component[component$csize > 1]$csize)
}

print(n.cluster)
```

```{r}
UD_graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)

UD_nogenes <- induced_subgraph(UD_graph, which(nodes$X1 != "gene"))

# Rimuovo i doppi nodi
UD_nogenes <- igraph::simplify(UD_nogenes)

betwennes.communities <- edge.betweenness.community(UD_nogenes, directed = FALSE, 
                                                    weights = E(UD_nogenes)$weight)

V(UD_nogenes)[betwennes.communities[[2]]]$X1
```
```{r}
nodes_results <- nodes %>% filter(X1 != "gene") %>% select(-X0)
nodes_results$Fastgreedy <- NA
nodes_results$Louvain <- NA
nodes_results$Spinglass <- NA
nodes_results$Markov <- NA
```

## Regola di clustering
Ogni cluster viene labellato con la label più frequente all'interno del cluster:
```{r}
label_cluster <- function(clusters)
{
  cluster_df <-
    as.data.frame(matrix(
      1:length(clusters),
      nrow = length(clusters),
      dimnames = list(NULL, "id")
    ))
  
  for (c in 1:length(clusters))
  {
    labels <- V(UD_nogenes)[clusters[[c]]]$X1
    labels <- labels[labels != "Multiple"]
    
    if (length(labels) != 0)
    {
      value <- which.max(unlist(table(labels)))

      cluster_df$name[cluster_df$id == c] <- names(value)[1]
    } else
    {
      cluster_df$name[cluster_df$id == c] <- "Multiple"
    }

  }
  
  return(cluster_df)
}
```

## Fastgreedy
Primo algoritmo di clustering:
```{r Fastgreedy_graph}
fgreedy.communities <- fastgreedy.community(UD_nogenes, modularity = TRUE, 
                                            weights = E(UD_nogenes)$weight)

V(UD_nogenes)[fgreedy.communities[[5]]]$X1

fgreedy.communities #IGRAPH clustering fast greedy, groups: 26 (communities), mod: 0.82 

plot_pretty_graph(UD_nogenes, "graphopt", fgreedy.communities$membership, 
                  length(fgreedy.communities), E(UD_nogenes)$weight, 
                  "Human Disease Network Fastgreedy Membership")

```


```{r}
fgreedy_cluster_df <- label_cluster(fgreedy.communities)

for (n in 1:length(fgreedy.communities$membership))
{
  nodes_results$Fastgreedy[n] <- fgreedy_cluster_df$name[fgreedy.communities$membership[n]]
}
```

## Louvain
Secondo algoritmo di clustering:
```{r Louvain_graph}
louvain.communities <- cluster_louvain(UD_nogenes, weights = E(UD_nogenes)$weight)

louvain.communities #IGRAPH clustering multi level, groups: 27 (communities), mod: 0.83 + groups:  

plot_pretty_graph(UD_nogenes, "graphopt", louvain.communities$membership, 
                  length(louvain.communities), E(UD_nogenes)$weight, 
                  "Human Disease Network Louvain Membership")

```

```{r}
louvain_cluster_df <- label_cluster(louvain.communities)

for (n in 1:length(louvain.communities$membership))
{
  nodes_results$Louvain[n] <- louvain_cluster_df$name[louvain.communities$membership[n]]
}

```
## Spinglass
Terzo algoritmo di clustering:
```{r Spinglass_graph}
spinglass.communities <- cluster_spinglass(UD_nogenes, spins = 225, 
                                           weights = E(UD_nogenes)$weight)

spinglass.communities 
#IGRAPH clustering spinglass, groups: varia... 39/43 ... (communities), mod: 0.4 

plot_pretty_graph(UD_nogenes, "graphopt", spinglass.communities$membership, 
                  length(spinglass.communities), E(UD_nogenes)$weight, 
                  "Human Disease Network Spinglass Membership")

```

```{r}
spinglass_cluster_df <- label_cluster(spinglass.communities)

for (n in 1:length(spinglass.communities$membership))
{
  nodes_results$Spinglass[n] <- spinglass_cluster_df$name[spinglass.communities$membership[n]]
}
```

## Markov Cluster Algorithm
Quarto algoritmo di clustering:
```{r Markov_graph}
library(MCL)
adjmat <- as_adj(UD_nogenes, type = "both", attr = "weight")

mcl.communities <- mcl(adjmat, addLoops = FALSE) # 71 cluster

plot_pretty_graph(UD_nogenes, "graphopt", mcl.communities$Cluster, 
                  length(mcl.communities), E(UD_nogenes)$weight, 
                  "Human Disease Network Markov Clusters")
```
Esempio di sottografo con label cancer
```{r Markov_cancer_graph}
mcl_cancer_subgraph <- induced_subgraph(UD_nogenes, 
                                        V(UD_nogenes)[mcl.communities$Cluster == 3])

ggraph(mcl_cancer_subgraph, layout="graphopt") +
  geom_edge_fan(aes(width=E(mcl_cancer_subgraph)$weight), 
                colour = "gray66", show.legend = FALSE) +
  geom_node_point(aes(fill="#8DD3C7"), shape=21, col="grey25", show.legend = FALSE) +
  scale_edge_width_continuous(range=c(0.2,0.9)) +
  scale_size_continuous(range=c(1, 10)) +
  theme_graph(base_size = 11, base_family = "sans") +
  ggtitle("Cancer MCL subgraph") 
```

```{r}
markov_cluster_df <- as.data.frame(matrix(1:(mcl.communities$K), nrow = mcl.communities$K, 
                                          dimnames = list(NULL, "id")))
markov_cluster_df$name <- NA
markov_cluster_df$id <- unique(mcl.communities$Cluster)

for (id in markov_cluster_df$id)
{

    labels <- V(UD_nogenes)[mcl.communities$Cluster == id]$X1
    labels <- labels[labels != "Multiple"]
    
    value <- which.max(unlist(table(labels)))
    
    
    if (length(value) != 0)
    {
      markov_cluster_df$name[markov_cluster_df$id == id] <- names(value)[1]
    }
}

for (n in 1:length(mcl.communities$Cluster))
{
  nodes_results$Markov[n] <- markov_cluster_df$name[mcl.communities$Cluster[n] == markov_cluster_df$id]
}
```

## Leiden Algorithm
Quinto algoritmo di clustering, dovrebbe migliorare i risultati e anche la rapidità di esecuzione di louvain:
```{r Leiden_graph}
library(leiden)

leiden.communities <- leiden(adjmat, resolution_parameter = 40)

print(max(leiden.communities))
leiden.communities <- make_clusters(UD_nogenes, membership = leiden.communities)

plot_pretty_graph(UD_nogenes, "graphopt", leiden.communities$membership, 
                  length(leiden.communities), E(UD_nogenes)$weight, 
                  "Human Disease Network Leiden Membership")
```

```{r}
leiden_cluster_df <- label_cluster(leiden.communities)

for (n in 1:length(leiden.communities$membership))
{
  nodes_results$Leiden[n] <- leiden_cluster_df$name[leiden.communities$membership[n]]
}
```

## Analysis 
Confusion matrix and accuracy

```{r}
library(caret)

compute_confmat <- function(groundtruth, communities.algo)
{
  l.union <- union(groundtruth, communities.algo)
  
  groundtruth[groundtruth == "Multiple"] <- communities.algo[groundtruth == "Multiple"]
  
  atable <-
    table(
      factor(groundtruth, l.union),
      factor(communities.algo, l.union)
    )
  
  return(confusionMatrix(atable))
}

fastgreedy_confmat <- compute_confmat(nodes_results$X1, nodes_results$Fastgreedy)

louvain_confmat <- compute_confmat(nodes_results$X1, nodes_results$Louvain)

spinglass_confmat <- compute_confmat(nodes_results$X1, nodes_results$Spinglass)

markov_confmat <- compute_confmat(nodes_results$X1, nodes_results$Markov)

leiden_confmat <- compute_confmat(nodes_results$X1, nodes_results$Leiden)

cat("fastgreedy")
fastgreedy_confmat$overall[1]

cat("louvain")
louvain_confmat$overall[1]

cat("spinglass")
spinglass_confmat$overall[1]

cat("markov")
markov_confmat$overall[1]

cat("leiden")
leiden_confmat$overall[1]
```
#### Analisi sulle malattie che venivano contrassegnate come Unclassified:
```{r}
unclassified_disease <- nodes_results %>% filter(X1 == "Unclassified")
unclassified_disease
```

- Bannayan-Riley-Ruvalcaba syndrome identificata da tutti e quattro gli algoritmi come cancer: 
da alcune risorse (https://omim.org/entry/158350?search=bannayan-riley-ruvalcaba%20syndrome&highlight=%22bannayan%20riley%20ruvalcaba%20syndrome%22%20%22bannayan%20riley%20ruvalcaba%20syndromic%22%20%22bannayan%20riley%20ruvalcaba%22%20%22bannayanrileyruvalcaba%20syndrome%22%20%22bannayanrileyruvalcaba%20syndromic%22%20bannayanrileyruvalcaba%20syndrome%20syndromic) pare ci sia un collegamento con il cancro al seno.

- Benzene toxicity susceptibility to : leukemia, post-chemotherapy, susceptibility to, included
breast cancer, post-chemotherapy poor survival in

- Aquaporin-1 deficiency classicifata in Hematological: 
collegamenti rilevati :Blood group, Colton


#### Analisi sulle malattie che venivano contrassegnate come Multiple:
```{r}
multiple_disease <- nodes_results %>% filter(X1 == "Multiple")
multiple_disease
```

- Fanconi anemia is a clinically and genetically heterogeneous disorder that causes genomic instability. Characteristic clinical features include developmental abnormalities in major organ systems, early-onset bone marrow failure, and a high predisposition to cancer

- Dejerine-Sottas neuropathy is a demyelinating peripheral neuropathy with onset in infancy

