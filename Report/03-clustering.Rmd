# Clustering

```{r message=FALSE, warning=FALSE, include=FALSE}
# source a set of functions
source("util.R")

# import libraries
libraries_list <- c("ggraph", "igraph", "dplyr", "readr", "DiagrammeR", "tidyverse", "Cairo", "networkD3", "CINNA", "scales", "gridExtra")
import_libraries(libraries_list)

# import graph
edges <- read.csv(
  "../dataset/diseasome [Edges].csv",
  head = TRUE
)

nodes <- read.csv(
  "../dataset/diseasome [Nodes].csv",
  head = TRUE
)

nodes <- nodes %>% select(-timeset)
edges <- edges %>% select(-timeset, -label)

graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)
# print(graph, e=TRUE, v=TRUE) ## IGRAPH 9af20f4 DNW- 1419 3926
```

Settiamo il peso di ogni arco pari al numero di geni che condividono le malattie:
```{r}
for (i in 1:length(edges[, 5]))
{
  edge <- edges[i, ]
  
  n1 <- V(graph)[as.character(edge$Source)]
  n2 <- V(graph)[as.character(edge$Target)]
  
  n1.neigh <- neighborhood(graph, nodes = n1)[[1]]
  n2.neigh <- neighborhood(graph, nodes = n2)[[1]]
  
  n1.neigh <- as.numeric(n1.neigh[n1.neigh$X1 == "gene"])
  n2.neigh <- as.numeric(n2.neigh[n2.neigh$X1 == "gene"])
  
  weight <- length(intersect(n1.neigh, n2.neigh))
  
  edges[i, ]$weight <- weight
}

graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)
```

Le malattie sono già clusterizzate in macrogruppi medici (cancro, cardiovascolare, etc...), proviamo a vedere se questi cluster si trovano vicini all'interno della rete:
```{r}
UD_nogenes <- induced_subgraph(graph, which(nodes$X1 != "gene"))

# Rimuovo i doppi nodi
UD_nogenes <- igraph::simplify(UD_nogenes)

disease_clusters <- unique(nodes$X1)

i = 1
for (disease in disease_clusters)
{
  V(UD_nogenes)[V(UD_nogenes)$X1 == disease]$color = i
  i = i + 1
}

ggraph(UD_nogenes, layout = "kk") +
  geom_edge_fan(colour = "gray", show.legend = TRUE) + 
  geom_node_point(aes(colour = V(UD_nogenes)$color)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Clusters")
```

```{r}
graphs <- NULL
plots <- NULL
i <- 1

for (disease in disease_clusters)
{
  if (disease == "gene")
    next
    
  graphs[[i]] <- induced.subgraph(UD_nogenes, which(V(UD_nogenes)$X1 == disease))
  
  if (disease %in% c("Unclassified", "Respiratory"))
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_node_point() +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  } else
  {
    plots[[i]] <- ggraph(graphs[[i]], layout = "kk") +
      geom_edge_fan(colour = "gray", show.legend = TRUE) +
      geom_node_point(colour = "red") +
      theme_graph(base_family = "sans", base_size = 11) +
      ggtitle(disease)
  }
  i = i + 1
}

# grid.arrange(grobs = plots)
```

Vediamo quante componenti connesse abbiamo per ogni cluster:
```{r}

n.cluster <- 0

for (g in graphs)
{
  component <- components(g)
  n.cluster = n.cluster + length(component[component$csize > 8]$csize)
}

print(n.cluster)
```

```{r}
UD_graph <- graph.data.frame(edges, directed = FALSE, vertices = nodes)

UD_nogenes <- induced_subgraph(UD_graph, which(nodes$X1 != "gene"))

# Rimuovo i doppi nodi
UD_nogenes <- igraph::simplify(UD_nogenes)

betwennes.communities <- edge.betweenness.community(UD_nogenes, directed = FALSE, weights = E(UD_nogenes)$weight)

V(UD_nogenes)[betwennes.communities[[2]]]$X1
```
```{r}
nodes_results <- nodes %>% filter(X1 != "gene") %>% select(-X0)
nodes_results$Fastgreedy <- NA
nodes_results$Louvain <- NA
nodes_results$Spinglass <- NA
nodes_results$Markov <- NA

```

## Regola di clustering
Ogni cluster viene labellato con la label più frequente all'interno del cluster:
```{r}
label_cluster <- function(clusters)
{
  cluster_df <-
    as.data.frame(matrix(
      1:length(clusters),
      nrow = length(clusters),
      dimnames = list(NULL, "id")
    ))
  
  for (c in 1:length(clusters))
  {
    labels <- V(UD_nogenes)[clusters[[c]]]$X1
    labels <- labels[labels != "Multiple"]
    
    value <- which.max(unlist(table(labels)))
    
    cluster_df$name[cluster_df$id == c] <-
      names(value)[1]
  }
  
  return(cluster_df)
}
```

## Fastgreedy
Primo algoritmo di clustering:
```{r}
fgreedy.communities <- fastgreedy.community(UD_nogenes, modularity = TRUE, weights = E(UD_nogenes)$weight)

V(UD_nogenes)[fgreedy.communities[[5]]]$X1

fgreedy.communities #IGRAPH clustering fast greedy, groups: 26 (communities), mod: 0.82 

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = fgreedy.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Fastgreedy Membership")

```


```{r}
fgreedy_cluster_df <- label_cluster(fgreedy.communities)

for (n in 1:length(fgreedy.communities$membership))
{
  nodes_results$Fastgreedy[n] <- fgreedy_cluster_df$name[fgreedy.communities$membership[n]]
}
```

## Louvain
Secondo algoritmo di clustering:
```{r}
louvain.communities <- cluster_louvain(UD_nogenes, weights = E(UD_nogenes)$weight)

louvain.communities #IGRAPH clustering multi level, groups: 27 (communities), mod: 0.83 + groups:  

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = louvain.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Louvain Membership")

```

```{r}
louvain_cluster_df <- label_cluster(louvain.communities)

for (n in 1:length(louvain.communities$membership))
{
  nodes_results$Louvain[n] <- louvain_cluster_df$name[louvain.communities$membership[n]]
}

```
## Spinglass
Terzo algoritmo di clustering:
```{r}
spinglass.communities <- cluster_spinglass(UD_nogenes, spins = 225, weights = E(UD_nogenes)$weight)

spinglass.communities #IGRAPH clustering spinglass, groups: varia... 39/43 ... (communities), mod: 0.4 

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = spinglass.communities$membership)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Spinglass Membership")

```

```{r}
spinglass_cluster_df <- label_cluster(spinglass.communities)

for (n in 1:length(spinglass.communities$membership))
{
  nodes_results$Spinglass[n] <- spinglass_cluster_df$name[spinglass.communities$membership[n]]
}
```

## Markov Cluster Algorithm
Quarto algoritmo di clustering:
```{r}
library(MCL)
adjmat <- as_adj(UD_nogenes, type = "both", attr = "weight")

mcl.communities <- mcl(adjmat, addLoops = FALSE) # 71 cluster

ggraph(UD_nogenes, layout = 'kk') +
  geom_edge_fan(colour = "gray") + 
  geom_node_point(aes(colour = mcl.communities$Cluster)) +
  labs(col="cluster") +
  scale_color_gradientn(colours = rainbow(5)) +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Human Disease Network Markov Clusters")

```
Esempio di sottografo con label cancer
```{r}
mcl_cancer_subgraph <- induced_subgraph(UD_nogenes, V(UD_nogenes)[mcl.communities$Cluster == 3])

ggraph(mcl_cancer_subgraph, layout = 'kk') +
  geom_edge_fan(colour = "gray", show.legend = TRUE) +
  geom_node_point(colour = "red") +
  theme_graph(base_family = "sans", base_size = 11) +
  ggtitle("Cancer MCL subgraph")
```

```{r}
markov_cluster_df <- as.data.frame(matrix(1:(mcl.communities$K), nrow = mcl.communities$K, dimnames = list(NULL, "id")))
markov_cluster_df$name <- NA
markov_cluster_df$id <- unique(mcl.communities$Cluster)

for (id in markov_cluster_df$id)
{

    labels <- V(UD_nogenes)[mcl.communities$Cluster == id]$X1
    labels <- labels[labels != "Multiple"]
    
    value <- which.max(unlist(table(labels)))
    
    
    if (length(value) != 0)
    {
      markov_cluster_df$name[markov_cluster_df$id == id] <- names(value)[1]
    }
}

for (n in 1:length(mcl.communities$Cluster))
{
  nodes_results$Markov[n] <- markov_cluster_df$name[mcl.communities$Cluster[n] == markov_cluster_df$id]
}
```

## Analysis 
Confusion matrix and accuracy

```{r}
library(caret)

compute_confmat <- function(groundtruth, communities.algo)
{
  l.union <- union(groundtruth, communities.algo)
  
  groundtruth[groundtruth == "Multiple"] <- communities.algo[groundtruth == "Multiple"]
  
  atable <-
    table(
      factor(groundtruth, l.union),
      factor(communities.algo, l.union)
    )
  
  return(confusionMatrix(atable))
}

fastgreedy_confmat <- compute_confmat(nodes_results$X1, nodes_results$Fastgreedy)

louvain_confmat <- compute_confmat(nodes_results$X1, nodes_results$Louvain)

spinglass_confmat <- compute_confmat(nodes_results$X1, nodes_results$Spinglass)

markov_confmat <- compute_confmat(nodes_results$X1, nodes_results$Markov)

cat("fastgreedy")
fastgreedy_confmat$overall[1]

cat("louvain")
louvain_confmat$overall[1]

cat("spinglass")
spinglass_confmat$overall[1]

cat("markov")
markov_confmat$overall[1]
```
#### Analisi sulle malattie che venivano contrassegnate come Unclassified:
```{r}
unclassified_disease <- nodes_results %>% filter(X1 == "Unclassified")
unclassified_disease
```

- Bannayan-Riley-Ruvalcaba syndrome identificata da tutti e quattro gli algoritmi come cancer: 
da alcune risorse (https://omim.org/entry/158350?search=bannayan-riley-ruvalcaba%20syndrome&highlight=%22bannayan%20riley%20ruvalcaba%20syndrome%22%20%22bannayan%20riley%20ruvalcaba%20syndromic%22%20%22bannayan%20riley%20ruvalcaba%22%20%22bannayanrileyruvalcaba%20syndrome%22%20%22bannayanrileyruvalcaba%20syndromic%22%20bannayanrileyruvalcaba%20syndrome%20syndromic) pare ci sia un collegamento con il cancro al seno.

- Benzene toxicity susceptibility to : leukemia, post-chemotherapy, susceptibility to, included
breast cancer, post-chemotherapy poor survival in

- Aquaporin-1 deficiency classicifata in Hematological: 
collegamenti rilevati :Blood group, Colton


#### Analisi sulle malattie che venivano contrassegnate come Multiple:
```{r}
multiple_disease <- nodes_results %>% filter(X1 == "Multiple")
multiple_disease
```

- Fanconi anemia is a clinically and genetically heterogeneous disorder that causes genomic instability. Characteristic clinical features include developmental abnormalities in major organ systems, early-onset bone marrow failure, and a high predisposition to cancer

- Dejerine-Sottas neuropathy is a demyelinating peripheral neuropathy with onset in infancy

